clear all;
close all;
clc;

%% Parameters
% Simulation Parameters 
dt = 0.01;
T_sim = 100;
scenario = 1;

DO_SIMULATION = true;
PLOT_DENSITY_FUNCTIONS = true;

%% Vehicles Parameters 
vel_lin_max = 100; 
vel_ang_max = 20; 
dimension = 3;  % Dimension of the UAV
numUAV = 6;
Kp = 50;   % Proportional gain for the linear velocity  
Ka = 15;   % Proportional gain for the angular velocity 
Ke = 10;   % Additional gain for the angular velocity 

% Generate random starting positions for each point
x = rand(numUAV, 1) * 100;   % Random x coordinates
y = 100 + rand(numUAV, 1) * 100;  % Random y coordinates
z = zeros(numUAV,1);
theta = zeros(numUAV,1);

states = [x, y, z, theta];

objective = ones(numUAV,1);     % - objective = 1 : the UAV is filled with
                                % water and is going to put out the fire
                                % - objective = 2 : the UAV is empty and is
                                % going to refill
                                % (we assume every one empty at the beginning)
objective_est = ones(numUAV,1);

% Dynamicc
fun = @(state, control, deltat) [state(1) + control(1) * cos(state(4)) * deltat, ...
                                 state(2) + control(1) * sin(state(4)) * deltat, ...
                                 state(3) + control(2) * deltat, ...
                                 state(4) + control(3) * deltat];
%{
 
% State Transition Matrix
A = [1, 0, 0, 0;
     0, 1, 0, 0;
     0, 0, 1, 0;
     0, 0, 0, 1];

% Control Matrix
B = @(theta,dt) dt * [cos(theta), 0, 0;
                      sin(theta), 0, 0;
                               0, 1, 0;
                               0, 0, 1]; 
%}

%% Kalman Filter Parameters
% Jacobian of the state model
J_A = @(control, theta, deltat) [1, 0, 0, -control(1) * sin(theta) * deltat;
                                 0, 1, 0, control(2) * cos(theta) * deltat;
                                 0, 0, 1, 0;
                                 0, 0, 0, 1];


% Matrix of the propagation of the process noise for (x,y,z,theta) 4x4
% We considered the nose as withe
G = @(theta, deltat) [cos(theta) * deltat,0,0;
              sin(theta) * deltat,0,0;
              0,deltat,0;
              0,0,deltat];

% Covariance of the process noise
std_u = [0.1, 0.1, 0.1]; % Uncertainty on the velocity (tang , z) and angular velocity
Q = diag(std_u.^2);

% Measurement Parameters
std_gps = 0.1; % Standard deviation of the GPS
std_gyro = 0.05; % Standard deviation of the gyroscope
std_ultrasonic = 0.1; % Standard deviation of the ultrasonic sensor
R = diag([std_gps^2, std_gps^2, std_ultrasonic^2, std_gyro^2]); % Covariance of the measurement noise

% Initial state (x,y,z,theta)
states_est = (states' + [std_gps * randn(2, numUAV); zeros(1, numUAV); std_gyro * randn(1, numUAV)])';

% Observation matrix (H)
H = [1,0,0,0;
     0,1,0,0;
     0,0,1,0;
     0,0,0,dt]; % ( me measure theta with a gyroscope)

% Covariance matrix of the initial estimate
P = eye(4) * 100; % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

% Map Parameters
dimgrid = [500 500 500];   % Define the dimensions of the grid

%% Fires Parameters
% Fires Positions
x_fire1 = 400;
y_fire1 = 400;
x_fire2 = 450;
y_fire2 = 50;
pos_fire1 = [x_fire1, y_fire1];
pos_fire2 = [x_fire2, y_fire2];

sigma_fire1 = 15;   % Standard deviation of the first fire
                    % (correspond to the extention of the fire)
sigma_fire2 = 15;   % Standard deviation of the second fire
                    % (correspond to the extention of the fire)
inc_threshold1 = sigma_fire1;  % Distance that has to be reach from the fire 1 
inc_threshold2 = sigma_fire2;  % Distance that has to be reach from the fire 2

%% Water Parameters
% Water Positions
x_water = 50;
y_water = 50;
pos_water = [x_water, y_water];

sigma_water = 60;
wat_threshold = sigma_water;   % Distance that has to be reach from the water source to refill


% Density Functions for the fires and the water
[G_fire,G_water] = objective_density_functions(dimgrid, pos_fire1,pos_fire2,pos_water,sigma_fire1,sigma_fire2,sigma_water,PLOT_DENSITY_FUNCTIONS);

G_fligt = create_flight_surface(dimgrid,scenario);

trajectories = zeros(numUAV, 4, T_sim/dt);
trajectories_est = zeros(numUAV, 4, T_sim/dt);



%% Simulation
if DO_SIMULATION
    
    count = 0;
    for t = 1:dt:T_sim

        count = count+1;


        % Model Simulation - REAL
        [control, objective] = modelSimulation_function(numUAV, dimgrid, states, objective, ...
            pos_fire1, pos_fire2, pos_water, inc_threshold1, inc_threshold2, wat_threshold, ...
            Kp, Ka, Ke, G_fire, G_water, G_fligt, vel_lin_max, vel_ang_max);
        
        for k = 1:numUAV
            states(k,:) = fun(states(k,:), control(k,:), dt);
            trajectories(k,:,count) = states(k,:);
        end

        % Model Simulation - ESTIMATED
        [control_est, objective_est] = modelSimulation_function(numUAV, dimgrid, states_est, objective_est, ...
            pos_fire1, pos_fire2, pos_water, inc_threshold1, inc_threshold2, wat_threshold, ...
            Kp, Ka, Ke, G_fire, G_water, G_fligt, vel_lin_max, vel_ang_max);
        
        % Extended Kalman Filter
        measure = (states' + [std_gps * randn(2, numUAV); zeros(1, numUAV); std_gyro * randn(1, numUAV)])';
        [states_est, P] = ExtendedKalmanFilter_function(states_est, measure, control_est, J_A, G, fun, Q, H, R, P, dt);

        
        for k = 1:numUAV
            trajectories_est(k,:,count) = states_est(k,:);
        end

        %% Plots
        % real        
        figure(3);clf
        colors = lines(numUAV);
        hold on;
        axis([0 dimgrid(1) 0 dimgrid(2) 0 dimgrid(3)]);
        xlabel('X Coordinate');
        ylabel('Y Coordinate');
        zlabel('Z Coordinate');
        title('Simulation');
        view(3);
        grid on;


        for i = 1:numUAV
            
            % Plot the current drone position as a marker
            plot3(states(i,1),states(i,2),states(i,3));
            
            drawUnicycle(states(i,1),states(i,2),states(i,4));

        end
        voronoi(states(:,1),states(:,2));

        plot3(x_fire1,y_fire1,0,'x','Color', 'r', 'MarkerSize', sigma_fire1)
        plot3(x_fire2,y_fire2,0,'x','Color', 'r', 'MarkerSize', sigma_fire2)
        
        % Plot the water
        r = sigma_water/2;                     % Raggio del cerchio
        theta = linspace(0, 2*pi, 100);  % Parametro angolare
        
        % Equazioni parametriche
        x_circle = r * cos(theta) + x_water;
        y_circle = r * sin(theta) + y_water;
        z_circle = zeros(size(theta));  
        plot3(x_circle, y_circle, z_circle, 'b', 'LineWidth', 2);

        drawnow;  % Force MATLAB to update the figure

        % estimated


    end

end